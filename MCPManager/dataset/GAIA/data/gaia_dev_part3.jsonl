{"unique_id": "000000000000001","Prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n given threshold.\n >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n False\n >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n True\n \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000001\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "has_close_elements","canonical_solution": " for idx, elem in enumerate(numbers):\n for idx2, elem2 in enumerate(numbers):\n if idx != idx2:\n distance = abs(elem - elem2)\n if distance < threshold:\n return True\n\n return False\n","test": "\n\nMETADATA = {\n 'author': 'jt',\n 'dataset': 'test'\n}\n\n\ndef check(candidate):\n assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n","file_name": "distance_check.py","Annotator Metadata": {"Steps": "1. Analyze the problem requirements to understand we need to check if any two numbers in the list have a distance less than the threshold\n2. Design an algorithm strategy, deciding to use nested loops to iterate through all pairs of numbers\n3. Implement the core logic, ensuring to skip comparisons with itself\n4. Add appropriate comments explaining the function purpose and parameter meanings\n5. Run test cases to verify the function behaves correctly with different inputs","Number of steps": "5","How long did this take?": "8 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000002","Prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000002\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "separate_paren_groups","canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n","file_name": "parentheses_separator.py","Annotator Metadata": {"Steps": "1. Analyze the problem requirements to understand we need to separate balanced parentheses groups\n2. Design an algorithm using depth tracking to identify complete groups\n3. Implement the solution tracking current depth and constructing groups\n4. Handle edge cases like spaces and nested parentheses\n5. Run test cases to verify the function works correctly with different inputs","Number of steps": "5","How long did this take?": "10 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000003","Prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000003\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "truncate_number","canonical_solution": "    return number % 1.0\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n","file_name": "decimal_part.py","Annotator Metadata": {"Steps": "1. Analyze the problem to understand we need to extract the decimal part of a float\n2. Design an algorithm using modulus operation to extract decimal part\n3. Implement the solution with a single line of code\n4. Verify the function works correctly with test cases\n5. Ensure the solution handles all valid inputs","Number of steps": "5","How long did this take?": "3 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000004","Prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000004\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "below_zero","canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n","file_name": "account_balance.py","Annotator Metadata": {"Steps": "1. Analyze the problem requirements to detect if an account balance ever falls below zero\n2. Design a simple algorithm to track balance and check for negative values\n3. Implement the solution with appropriate balance tracking\n4. Check edge cases like empty lists and alternating operations\n5. Verify the function works correctly with test cases","Number of steps": "5","How long did this take?": "5 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000005","Prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000005\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "mean_absolute_deviation","canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n","file_name": "mean_absolute_deviation.py","Annotator Metadata": {"Steps": "1. Understand the MAD formula and its components\n2. Calculate the mean of the dataset\n3. Compute absolute differences between each element and the mean\n4. Calculate the average of these absolute differences\n5. Test with various input lists to ensure correctness","Number of steps": "5","How long did this take?": "6 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000006","Prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000006\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "intersperse","canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n","file_name": "list_interspersion.py","Annotator Metadata": {"Steps": "1. Analyze the problem requirements to insert a delimiter between list elements\n2. Handle edge cases like empty lists\n3. Implement a solution to intersperse elements correctly\n4. Ensure the last element isn't followed by a delimiter\n5. Test with various inputs to verify correctness","Number of steps": "5","How long did this take?": "5 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000007","Prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000007\", \"Answer\": \"your_code_here\"}.","Level": 3,"entry_point": "parse_nested_parens","canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n","file_name": "parentheses_depth.py","Annotator Metadata": {"Steps": "1. Analyze the problem to calculate the maximum nesting depth of parentheses groups\n2. Design an algorithm to track depth and maximum depth for each group\n3. Create a helper function to process each parenthesis group\n4. Implement the complete solution with appropriate group splitting\n5. Verify the function works correctly with test cases","Number of steps": "5","How long did this take?": "10 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000008","Prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000008\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "filter_by_substring","canonical_solution": "    return [x for x in strings if substring in x]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n","file_name": "substring_filter.py","Annotator Metadata": {"Steps": "1. Understand the problem requirements to filter strings containing a specific substring\n2. Design a solution using list comprehension for efficiency\n3. Implement the filter with appropriate string containment check\n4. Test edge cases like empty lists\n5. Verify the function works correctly with various inputs","Number of steps": "5","How long did this take?": "3 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000009","Prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000009\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "sum_product","canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n","file_name": "sum_and_product.py","Annotator Metadata": {"Steps": "1. Analyze the problem to calculate both sum and product of a list\n2. Set appropriate default values for empty lists\n3. Implement logic to compute both values in a single loop\n4. Handle edge cases like empty lists and lists with zeros\n5. Return the values as a tuple in the correct order","Number of steps": "5","How long did this take?": "4 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000010","Prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000010\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "rolling_max","canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n","file_name": "rolling_maximum.py","Annotator Metadata": {"Steps": "1. Understand the problem to generate a list of rolling maximum values\n2. Design an algorithm to track the maximum value seen so far\n3. Implement the solution with proper initialization and updates\n4. Handle edge cases like empty lists\n5. Verify the function produces correct outputs for various test cases","Number of steps": "5","How long did this take?": "5 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000011","Prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000011\", \"Answer\": \"your_code_here\"}.","Level": 3,"entry_point": "make_palindrome","canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n","file_name": "palindrome_maker.py","Annotator Metadata": {"Steps": "1. Analyze the problem to understand the palindrome creation algorithm\n2. Identify the key components: finding the longest palindromic suffix\n3. Implement the logic to find where the palindromic suffix begins\n4. Construct the final palindrome by appending the reversed prefix\n5. Test with various inputs including edge cases like empty strings","Number of steps": "5","How long did this take?": "8 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000012","Prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000012\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "string_xor","canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n","file_name": "binary_xor.py","Annotator Metadata": {"Steps": "1. Understand the binary XOR operation at a character level\n2. Create a helper function to perform XOR on individual character pairs\n3. Implement the main function using zip to pair corresponding characters\n4. Join the resulting bits into a single string\n5. Test with various binary string inputs","Number of steps": "5","How long did this take?": "5 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000013","Prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000013\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "longest","canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n","file_name": "longest_string.py","Annotator Metadata": {"Steps": "1. Check for empty list and return None if found\n2. Find the maximum length among all strings\n3. Iterate through the list to find the first string with the maximum length\n4. Return the first string that matches the maximum length\n5. Ensure all edge cases are covered in the implementation","Number of steps": "5","How long did this take?": "4 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000014","Prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000014\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "greatest_common_divisor","canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n","file_name": "gcd.py","Annotator Metadata": {"Steps": "1. Understand the Euclidean algorithm for finding GCD\n2. Implement the iterative version of the algorithm\n3. Use the modulo operation to efficiently find the remainder\n4. Ensure the solution handles all test cases correctly\n5. Verify algorithm correctness with different integer inputs","Number of steps": "5","How long did this take?": "4 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000015","Prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000015\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "all_prefixes","canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n","file_name": "string_prefixes.py","Annotator Metadata": {"Steps": "1. Understand what a prefix is and how to generate them for a string\n2. Create an empty list to store the prefixes\n3. Loop through each position in the string\n4. For each position, slice the string from the beginning to that position\n5. Test with various inputs including empty strings","Number of steps": "5","How long did this take?": "3 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000016","Prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000016\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "string_sequence","canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n","file_name": "number_sequence.py","Annotator Metadata": {"Steps": "1. Generate a sequence of numbers from 0 to n inclusive\n2. Convert each number to a string\n3. Join the strings with spaces\n4. Return the resulting string\n5. Test with various inputs including edge cases","Number of steps": "5","How long did this take?": "2 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000017","Prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000017\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "count_distinct_characters","canonical_solution": "    return len(set(string.lower()))\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n","file_name": "unique_chars_counter.py","Annotator Metadata": {"Steps": "1. Convert the string to lowercase to ignore case differences\n2. Use a set to eliminate duplicate characters\n3. Count the number of elements in the set\n4. Return the count as the result\n5. Test with various inputs including empty strings and repeated characters","Number of steps": "5","How long did this take?": "2 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000018","Prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000018\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "parse_music","canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n","file_name": "music_notation_parser.py","Annotator Metadata": {"Steps": "1. Create a mapping from note symbols to their beat values\n2. Split the input string by spaces to get individual notes\n3. Convert each note to its corresponding beat value using the mapping\n4. Filter out any empty strings from the split result\n5. Return the list of beat values",  "Number of steps": "5",  "How long did this take?": "5 minutes",  "Tools": "1. Code quality checker\n2. Error detection tool",  "Number of tools": "2"}}
{"unique_id": "000000000000019","Prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000019\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "how_many_times","canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n","file_name": "substring_counter.py","Annotator Metadata": {"Steps": "1. Handle edge cases like empty strings\n2. Use a sliding window approach to check each possible position\n3. Compare each substring with the target substring\n4. Count matches including overlapping occurrences\n5. Test with various inputs including different patterns of overlapping","Number of steps": "5","How long did this take?": "6 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000020","Prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000020\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "sort_numbers","canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n","file_name": "word_number_sorter.py","Annotator Metadata": {"Steps": "1. Create a mapping from word representations to numerical values\n2. Split the input string into individual number words\n3. Sort the words based on their numerical values using the mapping\n4. Join the sorted words back into a space-delimited string\n5. Handle edge cases like empty strings and single words","Number of steps": "5","How long did this take?": "7 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000021","Prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000021\", \"Answer\": \"your_code_here\"}.","Level": 3,"entry_point": "find_closest_elements","canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n","file_name": "closest_pair.py","Annotator Metadata": {"Steps": "1. Analyze the problem to find the closest pair of numbers in a list\n2. Implement a nested loop to compare each pair of numbers\n3. Track the minimum distance and corresponding pair found so far\n4. Ensure numbers are returned in ascending order\n5. Handle all test cases including duplicate numbers","Number of steps": "5","How long did this take?": "8 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000022","Prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000022\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "rescale_to_unit","canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n","file_name": "linear_rescaling.py","Annotator Metadata": {"Steps": "1. Find the minimum and maximum values in the input list\n2. Apply a linear transformation to map the range to [0,1]\n3. Compute the rescaled value for each element in the list\n4. Return the list of rescaled values\n5. Verify the solution with test cases including edge cases","Number of steps": "5","How long did this take?": "5 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000023","Prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000023\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "filter_integers","canonical_solution": "    return [x for x in values if isinstance(x, int)]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n","file_name": "integer_filter.py","Annotator Metadata": {"Steps": "1. Understand the requirement to filter out non-integer values\n2. Use list comprehension for efficient filtering\n3. Apply the isinstance function to check for integer type\n4. Return the filtered list containing only integers\n5. Test with various inputs including mixed type lists","Number of steps": "5","How long did this take?": "3 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000024","Prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000024\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "strlen","canonical_solution": "    return len(string)\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n","file_name": "string_length.py","Annotator Metadata": {"Steps": "1. Use Python's built-in len function to get the string length\n2. Return the length value\n3. Verify the solution works for empty strings\n4. Test with single character strings\n5. Check with longer strings to ensure correctness","Number of steps": "5","How long did this take?": "1 minute","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000025","Prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000025\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "largest_divisor","canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n","file_name": "largest_divisor.py","Annotator Metadata": {"Steps": "1. Create a loop that iterates from n-1 down to 1\n2. Check if each number evenly divides n (remainder is zero)\n3. Return the first number found that divides n evenly\n4. Ensure the solution handles prime numbers correctly\n5. Test with various inputs including edge cases","Number of steps": "5","How long did this take?": "4 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000026","Prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000026\", \"Answer\": \"your_code_here\"}.","Level": 3,"entry_point": "factorize","canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n","file_name": "prime_factorization.py","Annotator Metadata": {"Steps": "1. Implement a prime factorization algorithm starting with the smallest factor (2)\n2. Use trial division to find prime factors iteratively\n3. Optimize by only checking factors up to the square root of n\n4. Handle the case where a prime factor larger than the square root remains\n5. Test with various inputs including prime numbers and perfect powers","Number of steps": "5","How long did this take?": "8 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000027","Prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000027\", \"Answer\": \"your_code_here\"}.","Level": 2,"entry_point": "remove_duplicates","canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n","file_name": "unique_elements.py","Annotator Metadata": {"Steps": "1. Use Counter to count occurrences of each number\n2. Filter the list to keep only elements that appear once\n3. Preserve the original order of elements\n4. Handle edge cases like empty lists\n5. Test with various inputs including lists with multiple duplicates","Number of steps": "5","How long did this take?": "4 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000028","Prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000028\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "flip_case","canonical_solution": "    return string.swapcase()\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n","file_name": "case_flipper.py","Annotator Metadata": {"Steps": "1. Use Python's built-in swapcase method to flip character cases\n2. Return the resulting string with inverted case\n3. Ensure the solution handles empty strings\n4. Test with strings containing mixed case letters\n5. Verify the solution works with special characters and punctuation","Number of steps": "5","How long did this take?": "2 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000029","Prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000029\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "concatenate","canonical_solution": "    return ''.join(strings)\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n","file_name": "string_concatenation.py","Annotator Metadata": {"Steps": "1. Use the join method with an empty separator to concatenate strings\n2. Handle edge cases like empty lists\n3. Return the joined string\n4. Test with various input lists\n5. Verify the solution works with different string contents","Number of steps": "5","How long did this take?": "2 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000030","Prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000030\", \"Answer\": \"your_code_here\"}.","Level": 1,"entry_point": "filter_by_prefix","canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n","test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n","file_name": "prefix_filter.py","Annotator Metadata": {"Steps": "1. Use list comprehension to filter strings efficiently\n2. Apply the startswith method to check for prefix matches\n3. Return the filtered list\n4. Handle edge cases like empty lists\n5. Test with various inputs including case-sensitive prefixes","Number of steps": "5","How long did this take?": "3 minutes","Tools": "1. Code quality checker\n2. Error detection tool","Number of tools": "2"}}
{"unique_id": "000000000000081", "Prompt": "\ndef is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000081\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "is_happy", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "file_name": "is_happy.py", "Annotator Metadata": {"Steps": "1. Check if the string length is at least 3, return False if not\n2. Iterate through the string, checking each triplet of consecutive characters\n3. For each triplet, check if any two characters are the same\n4. If duplicates are found in any triplet, return False\n5. If all triplets have distinct characters, return True", "Number of steps": "5", "How long did this take?": "4 minutes", "Tools": "1. String length checking\n2. String traversal\n3. Character comparison", "Number of tools": "3"}}
{"unique_id": "000000000000082", "Prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000082\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "file_name": "numerical_letter_grade.py", "Annotator Metadata": {"Steps": "1. Initialize an empty list for letter grades\n2. Iterate through each GPA in the input list\n3. Map each GPA to its corresponding letter grade using conditional statements\n4. Append each letter grade to the result list\n5. Return the list of letter grades", "Number of steps": "5", "How long did this take?": "5 minutes", "Tools": "1. List operations\n2. Conditional statements\n3. Floating-point comparison", "Number of tools": "3"}}
{"unique_id": "000000000000083", "Prompt": "\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000083\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "prime_length", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "file_name": "prime_length.py", "Annotator Metadata": {"Steps": "1. Calculate the length of the input string\n2. Handle edge cases: length 0 or 1 are not prime numbers\n3. Check if the length is divisible by any number from 2 to length-1\n4. If any number divides the length evenly, return False\n5. If no divisors are found, return True", "Number of steps": "5", "How long did this take?": "3 minutes", "Tools": "1. String length calculation\n2. Primality testing\n3. Loop iteration", "Number of tools": "3"}}
{"unique_id": "000000000000084", "Prompt": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000084\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "starts_one_ends", "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "file_name": "starts_one_ends.py", "Annotator Metadata": {"Steps": "1. Handle the special case for n=1\n2. Apply the mathematical formula for counting n-digit numbers that start or end with 1\n3. Calculate the result using the formula: 18 * 10^(n-2)", "Number of steps": "3", "How long did this take?": "4 minutes", "Tools": "1. Mathematical analysis\n2. Power calculation\n3. Conditional logic", "Number of tools": "3"}}
{"unique_id": "000000000000085", "Prompt": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000085\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "solve", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "file_name": "solve.py", "Annotator Metadata": {"Steps": "1. Convert the input integer to a string\n2. Sum the individual digits by converting each character back to an integer\n3. Convert the sum to binary using bin()\n4. Remove the '0b' prefix from the binary representation\n5. Return the binary string", "Number of steps": "5", "How long did this take?": "3 minutes", "Tools": "1. String conversion\n2. List comprehension\n3. Binary conversion", "Number of tools": "3"}}
{"unique_id": "000000000000086", "Prompt": "\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000086\", \"Answer\": \"your_code_here\"}.", "Level": 1, "entry_point": "add", "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "file_name": "add.py", "Annotator Metadata": {"Steps": "1. Filter the list to include only elements at odd indices (indices 1, 3, 5, etc.)\n2. Further filter to include only even elements\n3. Sum the resulting values\n4. Return the sum", "Number of steps": "4", "How long did this take?": "2 minutes", "Tools": "1. List comprehension\n2. Modulo operation\n3. Summation", "Number of tools": "3"}}
{"unique_id": "000000000000087", "Prompt": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000087\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "anti_shuffle", "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "file_name": "anti_shuffle.py", "Annotator Metadata": {"Steps": "1. Split the input string by spaces to get individual words\n2. For each word, convert it to a list of characters\n3. Sort the characters in ascending order based on ASCII value\n4. Join the sorted characters back into words\n5. Join the words with spaces to maintain the original spacing\n6. Return the resulting string", "Number of steps": "6", "How long did this take?": "3 minutes", "Tools": "1. String splitting\n2. Character sorting\n3. String joining", "Number of tools": "3"}}
{"unique_id": "000000000000088", "Prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000088\", \"Answer\": \"your_code_here\"}.", "Level": 3, "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "file_name": "get_row.py", "Annotator Metadata": {"Steps": "1. Find all coordinates (row, column) where the value equals x\n2. Sort the coordinates first by column in descending order\n3. Then sort by row in ascending order\n4. Return the sorted list of coordinates", "Number of steps": "4", "How long did this take?": "6 minutes", "Tools": "1. Nested list traversal\n2. List comprehension\n3. Custom sorting", "Number of tools": "3"}}
{"unique_id": "000000000000089", "Prompt": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000089\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "sort_array", "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "file_name": "sort_array.py", "Annotator Metadata": {"Steps": "1. Handle the empty array case\n2. For non-empty arrays, determine if the sum of first and last elements is odd or even\n3. If the sum is odd, sort in ascending order\n4. If the sum is even, sort in descending order\n5. Return the sorted array without modifying the original", "Number of steps": "5", "How long did this take?": "3 minutes", "Tools": "1. Array sorting\n2. Parity checking\n3. Conditional logic", "Number of tools": "3"}}
{"unique_id": "000000000000090", "Prompt": "\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000090\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "encrypt", "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "file_name": "encrypt.py", "Annotator Metadata": {"Steps": "1. Define the alphabet string\n2. Initialize an empty output string\n3. Iterate through each character in the input string\n4. If the character is in the alphabet, shift it by 4 positions (2*2)\n5. Handle wrapping around the alphabet using modulo\n6. If the character is not in the alphabet, keep it unchanged\n7. Return the encrypted string", "Number of steps": "7", "How long did this take?": "4 minutes", "Tools": "1. String manipulation\n2. Character indexing\n3. Modular arithmetic", "Number of tools": "3"}}
{"unique_id": "000000000000091", "Prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000091\", \"Answer\": \"your_code_here\"}.", "Level": 1, "entry_point": "next_smallest", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "file_name": "next_smallest.py", "Annotator Metadata": {"Steps": "1. Remove duplicates from the list using set()\n2. Sort the list in ascending order\n3. Check if the list has at least 2 elements\n4. Return the second element (index 1) if there are at least 2 elements\n5. Return None otherwise", "Number of steps": "5", "How long did this take?": "2 minutes", "Tools": "1. Set conversion\n2. Sorting\n3. Conditional logic", "Number of tools": "3"}}
{"unique_id": "000000000000092", "Prompt": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000092\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "is_bored", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "file_name": "is_bored.py", "Annotator Metadata": {"Steps": "1. Import regex module\n2. Split the input string into sentences using regex\n3. Check each sentence to see if it starts with 'I '\n4. Count the number of sentences that start with 'I '\n5. Return the count", "Number of steps": "5", "How long did this take?": "3 minutes", "Tools": "1. Regular expressions\n2. String splitting\n3. List comprehension", "Number of tools": "3"}}
{"unique_id": "000000000000093", "Prompt": "\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n  \n\n    \n    '''\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000093\", \"Answer\": \"your_code_here\"}.", "Level": 1, "entry_point": "any_int", "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "file_name": "any_int.py", "Annotator Metadata": {"Steps": "1. Check if all three input numbers are integers using isinstance()\n2. If they are all integers, check if any number equals the sum of the other two\n3. Return True if both conditions are met, False otherwise", "Number of steps": "3", "How long did this take?": "2 minutes", "Tools": "1. Type checking\n2. Arithmetic operations\n3. Logical operations", "Number of tools": "3"}}
{"unique_id": "000000000000094", "Prompt": "\ndef encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000094\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "file_name": "encode.py", "Annotator Metadata": {"Steps": "1. Define a string containing all vowels (both lowercase and uppercase)\n2. Create a dictionary mapping each vowel to the character 2 places ahead in the alphabet\n3. Swap the case of all letters in the input message\n4. Process each character, replacing vowels with their mapped characters\n5. Join the processed characters and return the result", "Number of steps": "5", "How long did this take?": "4 minutes", "Tools": "1. String manipulation\n2. Character encoding/ASCII operations\n3. Dictionary mapping\n4. List comprehension", "Number of tools": "4"}}
{"unique_id": "000000000000095", "Prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000095\", \"Answer\": \"your_code_here\"}.", "Level": 3, "entry_point": "skjkasdkd", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "file_name": "skjkasdkd.py", "Annotator Metadata": {"Steps": "1. Define a helper function to check if a number is prime\n2. Initialize a variable to track the maximum prime number found\n3. Iterate through each number in the input list\n4. For each number, check if it's prime and greater than the current maximum\n5. Update the maximum if conditions are met\n6. Convert the maximum prime number to a string and sum its digits\n7. Return the sum", "Number of steps": "7", "How long did this take?": "5 minutes", "Tools": "1. Prime number checking\n2. Maximum value tracking\n3. Digit sum calculation", "Number of tools": "3"}}
{"unique_id": "000000000000096", "Prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000096\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "check_dict_case", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "file_name": "check_dict_case.py", "Annotator Metadata": {"Steps": "1. Check if the dictionary is empty, return False if it is\n2. Initialize a state variable to track the case pattern\n3. Iterate through all keys in the dictionary\n4. Check if each key is a string, if not, set state to 'mixed' and break\n5. Determine the case pattern (upper or lower) from the first key\n6. Check if subsequent keys follow the same case pattern\n7. Return True if all keys are either all uppercase or all lowercase", "Number of steps": "7", "How long did this take?": "5 minutes", "Tools": "1. Dictionary operations\n2. Type checking\n3. String case testing", "Number of tools": "3"}}
{"unique_id": "000000000000097", "Prompt": "\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000097\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "count_up_to", "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "file_name": "count_up_to.py", "Annotator Metadata": {"Steps": "1. Initialize an empty list to store prime numbers\n2. Iterate through numbers from 2 to n-1\n3. For each number, check if it's prime by testing divisibility by smaller numbers\n4. If a number is prime, add it to the result list\n5. Return the list of prime numbers", "Number of steps": "5", "How long did this take?": "4 minutes", "Tools": "1. Primality testing\n2. List building\n3. Range iteration", "Number of tools": "3"}}
{"unique_id": "000000000000098", "Prompt": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000098\", \"Answer\": \"your_code_here\"}.", "Level": 1, "entry_point": "multiply", "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "file_name": "multiply.py", "Annotator Metadata": {"Steps": "1. Extract the unit digit from the first number using modulo 10\n2. Extract the unit digit from the second number using modulo 10\n3. Handle negative numbers by taking the absolute value of each unit digit\n4. Multiply the two unit digits together\n5. Return the product", "Number of steps": "5", "How long did this take?": "2 minutes", "Tools": "1. Modulo operation\n2. Absolute value calculation\n3. Multiplication", "Number of tools": "3"}}
{"unique_id": "000000000000099", "Prompt": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000099\", \"Answer\": \"your_code_here\"}.", "Level": 1, "entry_point": "count_upper", "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "file_name": "count_upper.py", "Annotator Metadata": {"Steps": "1. Initialize a counter variable to 0\n2. Iterate through the string, considering only characters at even indices (0, 2, 4, etc.)\n3. Check if each character is an uppercase vowel (A, E, I, O, U)\n4. Increment the counter for each uppercase vowel found\n5. Return the final count", "Number of steps": "5", "How long did this take?": "2 minutes", "Tools": "1. String traversal\n2. Character checking\n3. Counter incrementing", "Number of tools": "3"}}
{"unique_id": "000000000000100", "Prompt": "\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n\nPlease use MCP to check for any potential errors in your code before finalizing your solution. Write the solution and save it in a jsonl file named answer.jsonl using the format {\"unique_id\": \"000000000000100\", \"Answer\": \"your_code_here\"}.", "Level": 2, "entry_point": "closest_integer", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "file_name": "closest_integer.py", "Annotator Metadata": {"Steps": "1. Import necessary math functions\n2. Clean up the input string by removing trailing zeros for decimal numbers\n3. Convert the string to a float\n4. Handle the special case for numbers ending with .5\n5. For .5 cases, round away from zero (ceil for positive, floor for negative)\n6. For other cases, use standard rounding\n7. Return the result as an integer", "Number of steps": "7", "How long did this take?": "5 minutes", "Tools": "1. String manipulation\n2. Type conversion\n3. Mathematical rounding", "Number of tools": "3"}}